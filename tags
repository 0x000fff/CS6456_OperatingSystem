!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
KSEG	bootload.asm	/^KSEG	equ	0x1000		;kernel goes into memory at 0x10000$/;"	d
KSIZE	bootload.asm	/^KSIZE	equ	10		;kernel is at most 10 sectors (and probably less)$/;"	d
KSTART	bootload.asm	/^KSTART	equ	3		;kernel lives at sector 3 (makes room for map & dir)$/;"	d
_interrupt	kernel.asm	/^_interrupt:$/;"	l
_interrupt	lib.asm	/^_interrupt:$/;"	l
_interrupt21ServiceRoutine	kernel.asm	/^_interrupt21ServiceRoutine:$/;"	l
_launchProgram	kernel.asm	/^_launchProgram:$/;"	l
_makeInterrupt21	kernel.asm	/^_makeInterrupt21:$/;"	l
_printhex	kernel.asm	/^_printhex:$/;"	l
_putInMemory	kernel.asm	/^_putInMemory:$/;"	l
deleteFile	kernel.c	/^void deleteFile(char* filename)$/;"	f
directory	kernel.c	/^void directory()$/;"	f
executeProgram	kernel.c	/^void executeProgram(char* name, int segment)$/;"	f
f	Makefile	/^	dd if=bootload of=floppya.img bs=512 count=1 conv=notrunc$/;"	m
f	Makefile	/^	dd if=dir.img of=floppya.img bs=512 count=1 seek=2 conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernel of=floppya.img bs=512 conv=notrunc seek=3$/;"	m
f	Makefile	/^	dd if=map.img of=floppya.img bs=512 count=1 seek=1 conv=notrunc$/;"	m
f	Makefile	/^	dd if=message.txt of=floppya.img bs=512 count=1 seek=30 conv=notrunc$/;"	m
handleInterrupt21	kernel.c	/^void handleInterrupt21(int AX, int BX, int CX, int DX)$/;"	f
intr	kernel.asm	/^intr:	int #0x00	;call the interrupt (00 will be changed above)$/;"	l
intr	lib.asm	/^intr:	int #0x00	;call the interrupt (00 will be changed above)$/;"	l
jump	kernel.asm	/^jump:	jmp #0x0000:0x0000	;and start running (the first 0000 is changed above)$/;"	l
main	kernel.c	/^void main()$/;"	f
main	loadFile.c	/^main(int argc, char* argv[])$/;"	f
myDIV	kernel.c	/^int myDIV(int dividend, int divisor)$/;"	f
myMOD	kernel.c	/^int myMOD(int dividend, int divisor)$/;"	f
ph1	kernel.asm	/^ph1:    add al,#0x30$/;"	l
ph2	kernel.asm	/^ph2:    add al,#0x30$/;"	l
ph3	kernel.asm	/^ph3:    add al,#0x30$/;"	l
ph4	kernel.asm	/^ph4:    add al,#0x30$/;"	l
pop	kernel.asm	/^	pop ds$/;"	d
pop	kernel.asm	/^	pop dx$/;"	d
pop	lib.asm	/^	pop ds$/;"	d
printString	kernel.c	/^void printString(char* str)$/;"	f
push	kernel.asm	/^	push ds		;use self-modifying code to call the right interrupt$/;"	d
push	kernel.asm	/^	push ds$/;"	d
push	kernel.asm	/^	push dx$/;"	d
push	lib.asm	/^	push ds		;use self-modifying code to call the right interrupt$/;"	d
readFile	kernel.c	/^void readFile(char* filename, char* outbuf)$/;"	f
readSector	kernel.c	/^void readSector(char* buffer, int sector)$/;"	f
readString	kernel.c	/^void readString(char buffer[])$/;"	f
true	kernel.c	1;"	d	file:
writeFile	kernel.c	/^void writeFile(char* filename, char* inbuf)$/;"	f
writeSector	kernel.c	/^void writeSector(char* buffer, int sector)$/;"	f
